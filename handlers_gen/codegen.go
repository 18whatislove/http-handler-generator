package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"reflect"
	"strings"
	"text/template"
)

//go:generate go build handlers_gen/ && ./codegen.exe api.go api_handlers.go

type Field struct {
	Name, Type, ParamName string
	Default               struct {
		IsSet bool
		Value string
	}
	Required bool
	Min, Max struct {
		IsSet bool
		Value string
	}
	Enum struct {
		IsSet bool
		Value string
	}
}

const (
	genPrefix string = "// apigen:api"
	sample    string = `
	func response(w http.ResponseWriter, data interface{}, status int) {
		j, err := json.Marshal(data)
		if err != nil {
			panic(err)
		}
		w.WriteHeader(status)
		w.Write(j)
	}

{{ range $structName, $methods := . }}
{{ range $method := $methods }}

func (srv *{{ $structName }}) handler{{ $method.Name }}(w http.ResponseWriter, r *http.Request) {
	{{ if $method.Config.Auth }}// check auth token
	if !IsAuthorized(r) {
		response(w, map[string]string{"error": "unauthorized"}, http.StatusForbidden)
		return
	}{{ end }}
	s := new({{ $method.ParamStruct }})
	r.ParseForm()
	
	// fill struct
	if err := s.Fill(r.Form); err != nil {
		err := err.(ApiError)
		response(w, map[string]string{"error": err.Error()}, err.HTTPStatus)
		return 
	}
	// struct validation
	if err := s.Validate(); err != nil {
		response(w, map[string]string{"error": err.Error()}, http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	res, err := srv.{{ $method.Name }}(ctx, *s)
	if err != nil {
		var statusCode int
		if err, ok := err.(ApiError); ok {
			statusCode = err.HTTPStatus
		} else {
			statusCode = http.StatusInternalServerError
		}
		response(w, map[string]string{"error": err.Error()}, statusCode)
		return
	}
	response(w, map[string]interface{}{
		"error": "",
		"response": res,
	}, http.StatusOK)
}
{{ end }}
	
func (srv *{{ $structName }}) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var method string = r.Method
	switch r.URL.Path {
	{{ range $method := $methods }}
	case "{{ $method.Config.Path }}": 
		{{- if eq $method.Config.HTTPMethod "" }}if method == "GET" || method == "POST"{{- else}}if method == "{{ $method.Config.HTTPMethod }}"{{- end}}{
			srv.handler{{ $method.Name }}(w, r)
		} else { 
			response(w, map[string]string{"error": "bad method"}, http.StatusNotAcceptable)
		}
	{{ end }}
	default:
		response(w, map[string]string{"error": "unknown method"}, http.StatusNotFound)
	}
}
{{ end }}`
	helpers string = ``
)

// func Render(t *template.Template, data interface{}, output io.Writer) error {}

type (
	Config struct {
		Path       string `json:"url"`
		HTTPMethod string `json:"method"`
		Auth       bool   `json:"auth"`
	}
	Method struct {
		Name        string
		ParamStruct string
		Config      *Config
	}
	// Struct struct {
	// 	name string
	// 	methods []*Method
	// }
)

func main() {
	out, err := os.Create(os.Args[2])
	if err != nil {
		panic(err)
	}
	defer out.Close()
	filename := os.Args[1]
	// filename := "../api.go"
	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, filename, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	buf := &bytes.Buffer{}

	imports := []string{"\"unicode/utf8\"", "\"net/url\"", "\"strconv\"", "\"encoding/json\"",
		"\"strings\"", "\"net/http\"", "\"fmt\""}
	// imports = append(imports, getImports(f)...)

	importsTemplate := template.Must(template.New("imports").Parse(`
	package {{ .package }}

	import ({{ range $importName := .imports }}{{ $importName }};{{ end }})`))
	importsTemplate.Execute(buf, map[string]interface{}{
		"imports": imports,
		"package": f.Name.Name,
	})
	buf.WriteString("\n\n// Code generated by codegen for params validation. DO NOT EDIT.\n\n")

	buf.WriteString(`
	// helpers
	func IsAuthorized(r *http.Request) bool {
		return r.Header.Get("X-Auth") == "100500"
	}

	func MinLengthValidation(limitLength, length int) bool {
		return MinValueValidation(limitLength, length)
	}

	func MinValueValidation(limitValue, value int) bool {
		return value >= limitValue
	}
	
	func MaxLengthValidation(limitLength, length int) bool {
		return MaxValueValidation(limitLength, length)
	}

	func MaxValueValidation(limitValue, value int) bool {
		return value <= limitValue
	}

	func IsOneOfTheIntOptions(options []int, selectedOption int) bool {
		for _, option := range options {
			if selectedOption == option {
				return true
			}
		}
		return false
	}

	func IsOneOfTheStringOptions(options []string, selectedOption string) bool {
		for _, option := range options {
			if selectedOption == option {
				return true
			}
		}
		return false
	}
	`)

	// buf.WriteString("package " + f.Name.Name)
	// node := &ast.File{Name: f.Name}
	// for _, decl := range f.Decls {
	// 	decl, ok := decl.(*ast.GenDecl)
	// 	if !ok {
	// 		continue
	// 	}
	// 	if decl.Tok == token.IMPORT {
	// 		node.Decls = append(node.Decls, decl)
	// 	}
	// }
	// decl := &ast.GenDecl{}
	// node.Decls = append(node.Decls, decl)
	// if err := format.Node(os.Stdout, token.NewFileSet(), node); err != nil {
	// 	panic(err)
	// }

	// fmt.Fprintln(os.Stdout, buf)
	// err = ast.Print(fs, f)
	// if err != nil {
	// 	panic(err)
	// }
	// return

	paramStructs := make(map[string]struct{})
	// methods parse
	targets := make(map[string][]*Method)

	for _, decl := range f.Decls {
		decl, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if decl.Doc == nil {
			continue
		}
		label := decl.Doc.List[0].Text
		if !strings.HasPrefix(label, genPrefix) { // || !strings.HasPrefix(label, "//apigen:api")
			continue
		}
		// parse handler conditions from json
		config := new(Config)
		err := json.Unmarshal([]byte(label[strings.Index(label, "{"):]), config)
		if err != nil {
			log.Println("bad json:", label[strings.Index(label, "{"):])
			panic(err)
		}

		// if config.HTTPMethod == "" {
		// 	config.HTTPMethod = "GET"
		// }

		// method signature
		var structType string
		if decl.Type.Params != nil {
			// need second param (its type) cause first is a ctx
			// if len(decl.Type.Params.List) == 2 { ... }
			structType = decl.Type.Params.List[1].Type.(*ast.Ident).Name

			if _, exists := paramStructs[structType]; !exists {
				paramStructs[structType] = struct{}{}
			}
		}

		structName := decl.Recv.List[0].Type.(*ast.StarExpr).X.(*ast.Ident).Name
		m := &Method{Name: decl.Name.Name,
			Config:      config,
			ParamStruct: structType}

		if methods, exists := targets[structName]; exists {
			methods = append(methods, m)
			targets[structName] = methods
		} else {
			targets[structName] = []*Method{m}
		}
	}
	t1 := template.Must(template.New("").Parse(sample))
	err = t1.Execute(buf, targets)
	// err = t1.Execute(os.Stdout, targets)
	if err != nil {
		panic(err)
	}
	// structs parse
	sts := make(map[string][]*Field, 0)
	for _, decl := range f.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range decl.Specs {
			spec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			_, ok = paramStructs[spec.Name.Name] // CreateParams, ProfileParams,...
			if !ok {
				continue
			}

			structType, ok := spec.Type.(*ast.StructType)
			if !ok {
				continue
			}
			// if structType.Fields.List != nil ...
			fds := make([]*Field, 0, len(structType.Fields.List))
			for _, field := range structType.Fields.List {
				// if field.Tag != nil ...
				tag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1]).Get("apivalidator")
				if tag == "" {
					continue
				}
				f := &Field{
					Name:      field.Names[0].Name,
					Type:      field.Type.(*ast.Ident).Name,
					ParamName: strings.ToLower(field.Names[0].Name),
				}
				tagValue2Struct(tag, f)
				fds = append(fds, f)
			}
			sts[spec.Name.Name] = fds
		}
	}
	// Fill method
	fillMethodTempl := `
	{{- $LB := "{"}}
	{{- $RB := "}"}}
	{{ range $structName, $structFields := . }} 
	func (p *{{ $structName }}) Fill(data url.Values) error {{$LB}}
		err := ApiError{HTTPStatus: http.StatusBadRequest}

		{{ range $field := $structFields }}
		{{ if $field.Required }}
		if data.Get("{{ $field.ParamName }}") == "" {
			err.Err = fmt.Errorf("{{ $field.ParamName }} must me not empty")
			return err
		}
		{{ end }}
		{{ if $field.Default.IsSet }}
		if data.Get("{{ $field.ParamName }}") == "" {
			p.{{ $field.Name }} = {{ $field.Default.Value }} // default
		} else {
			{{ if eq $field.Type "int" }}
			if value, convErr := strconv.Atoi(data.Get("{{ $field.ParamName }}")); convErr != nil {
				err.Err = fmt.Errorf("{{ $field.ParamName }} must be {{ $field.Type }}")
				return err
			} else {
				p.{{ $field.Name }} = value
			}
			{{else}}
			p.{{ $field.Name }} = data.Get("{{ $field.ParamName }}")
			{{ end }}
		}
		{{ else }}
		{{ if eq $field.Type "int" }}
		if value, convErr := strconv.Atoi(data.Get("{{ $field.ParamName }}")); convErr != nil {
			err.Err = fmt.Errorf("{{ $field.ParamName }} must be {{ $field.Type }}")
			return err
		} else {
			p.{{ $field.Name }} = value
		}
		{{ else }}
		p.{{ $field.Name }} = data.Get("{{ $field.ParamName }}")
		{{ end }}
		{{ end }}
		{{end}}
		return nil
	{{$RB}}
	{{ end }}
	{{template "validate.tmpl" .}}
	`

	checkers := `
	// string
	{{ define "string.min" }}
	if ok := MinLengthValidation({{ .Min.Value }}, utf8.RuneCountInString(p.{{ .Name }})); !ok {
		return fmt.Errorf("{{ .ParamName }} len must be >= {{ .Min.Value }}")
	}
	{{ end }}
	{{ define "string.max" }}
	if ok := MaxLengthValidation({{ .Max.Value }}, utf8.RuneCountInString(p.{{ .Name }})); !ok {
		return fmt.Errorf("{{ .ParamName }} len must be <= {{ .Max.Value }}")
	}
	{{ end }}
	{{ define "string.existence" }}
	if ok := IsOneOfTheStringOptions({{ .Enum.Value }}, p.{{ .Name }}); !ok {
		return fmt.Errorf("{{ .ParamName }} must be one of [%s]", strings.Join({{ .Enum.Value }}, ", "))
	}
	{{ end }}

	{{ define "int.min" }}
	if ok := MinValueValidation({{ .Min.Value }}, p.{{ .Name }}); !ok {
		return fmt.Errorf("{{ .ParamName }} must be >= {{ .Min.Value }}")
	}
	{{ end }}
	{{ define "int.max" }}
	if ok := MaxValueValidation({{ .Max.Value }}, p.{{ .Name }}); !ok {
		return fmt.Errorf("{{ .ParamName }} must be <= {{ .Max.Value }}")
	}
	{{ end }}
	{{ define "int.existence" }}
	if ok := IsOneOfTheIntOptions({{ print .Enum.Value }}, p.{{ .Name }}); !ok {
		return fmt.Errorf("{{ .ParamName }} must be one of [%s]", strings.Split({{ .Enum.Value }}, ", "))
	}
	{{ end }}

	`

	// var b bytes.Buffer
	// t := template.Must(template.New("filling").Parse(fillMethodTempl))
	// buf.Grow(len(fillMethodTempl) + 100)
	// t.Execute(&b, sts)

	// Validation method
	// validTempl := "validation_template.txt"
	// t3 := template.Must(template.ParseFiles(validTempl))
	t3 := template.Must(template.New("").Parse(checkers))
	t3, err = t3.Parse(`
	{{define "validate.tmpl"}}
	{{ $RB := "}" }}
	{{ $LB := "{" }}
	{{- range $structName, $structFields := . }}func (p *{{ $structName }}) Validate() error {{ $LB }}
	{{- range $field := $structFields }}
	// {{- $field.Name }}
	{{- if eq $field.Type "string" }}
	{{- if $field.Max.IsSet }}{{template "string.max" $field}}{{ end }}
	{{- if $field.Min.IsSet }}{{template "string.min" $field}}{{ end }}
	{{- if $field.Enum.IsSet }}{{template "string.existence" $field}}{{ end }}
	{{ end }}
	{{- if eq $field.Type "int" }}
	{{- if $field.Max.IsSet }}{{template "int.max" $field}}{{ end }}
	{{- if $field.Min.IsSet }}{{template "int.min" $field}}{{ end }}
	{{- if $field.Enum.IsSet }}{{template "int.existence" $field}}{{ end }}
	{{ end }}
	{{ end }}
	return nil
	{{$RB}}{{"\n"}}
	{{- end }}
	{{end}}`)
	if err != nil {
		panic(err)
	}
	t3, err = t3.Parse(fillMethodTempl)
	if err != nil {
		panic(err)
	}

	err = t3.Execute(buf, sts)
	if err != nil {
		panic(err)
	}
	// err = t3.Execute(&b, sts)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Print(b.String())
	// res, err := format.Source(b.Bytes())
	// if err != nil {
	// 	panic(err)
	// }
	res, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	// fmt.Println(string(res))
	_, err = fmt.Fprint(out, string(res))
	if err != nil {
		fmt.Println(err)
	}
}

// {{ if $field.Required }}
// if data["{{ $field.ParamName }}"] == "" {
// 	err.Err = fmt.Errorf("{{ $field.ParamName }} must me not empty")
// 	goto END
// }
// {{ end }}
// {{ if $field.Default.IsSet }}
// if data["{{ $field.ParamName }}"] == "" {
// 	p.{{ $field.Name }} = {{ $field.Default.Value }} // default
// } else {
// 	{{ if eq $field.Type "int" }}
// 	value, err := strconv.Atoi(data["{{ $field.ParamName }}"])
// 	if err != nil {
// 		err.Err = fmt.Errorf("{{ $field.ParamName }} must be {{ $field.Type }}")
// 		goto END
// 	}
// 	p.{{ $field.Name }} = value
// 	{{continue}}
// 	{{ end }}
// 	p.{{ $field.Name }} = data["{{ $field.ParamName }}"]
// }
// {{continue}}
// {{ end }}
// {{ if eq $field.Type "int" }}
// value, err = strconv.Atoi(data["{{ $field.ParamName }}"])
// if err != nil {
// 	err.Err = fmt.Errorf("{{ $field.ParamName }} must be {{ $field.Type }}")
// 	goto END
// }
// p.{{ $field.Name }} = value
// {{continue}}
// {{ end }}
// p.{{ $field.Name }} = data["{{ $field.ParamName }}"]
// {{ end }}
// END:
// return err

// {{ range $field := $structFields }}
// if value, ok := data["{{ $field.ParamName }}"]; ok {
// 	if value, ok := value.({{$field.Type}}); ok {
// 		{{- if $field.Required }}
// 		if value == {{if eq $field.Type "int"}}0{{else}}""{{end}} {
// 			err.Err = fmt.Errorf("{{ $field.ParamName }} must me not empty")
// 			return err
// 		}
// 		{{- end }}
// 		p.{{$field.Name}} = value
// 	} else {
// 		err.Err = fmt.Errorf("{{ $field.ParamName }} must be {{ $field.Type }}")
// 		return err
// 	}
// } {{ if or $field.Default.IsSet $field.Required }} else {
// 	{{- if $field.Required }}
// 	err.Err = fmt.Errorf("{{ $field.ParamName }} must me not empty")
// 	return err
// 	{{- end }}
// 	{{- if $field.Default.IsSet }}
// 	// default
// 	p.{{ $field.Name }} = {{ $field.Default.Value }}
// 	{{- end }}
// }
// {{ end }}

// {{ end }}
